<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Tak Online</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="/js/three.min.js"></script>
    <script src="/js/jquery.min.js"></script>
    <script>
      var player = null;
      var url = window.location.href.split("/");
      var gameId = url[url.length - 1];
      var white_texture = THREE.ImageUtils.loadTexture( '../images/white_piece.png' );
      var black_texture = THREE.ImageUtils.loadTexture( '../images/black_piece.png' );
      var p1_material = new THREE.MeshBasicMaterial( { map: white_texture } );;
      var p2_material = new THREE.MeshBasicMaterial( { map: black_texture } );;
      var capstone = new THREE.SphereGeometry(0.5, 32, 32, 0, Math.PI, 0, Math.PI );
      var flatstone = new THREE.BoxGeometry(1, 1, 0.25);
      var grid = null;
      var board_parts = [];

      $.get("/game/" + gameId + "/player", function(data, status) {
        player = data.player;
      });

      var scene = new THREE.Scene();
      var game_size = 5;
      var aspect = window.innerWidth / window.innerHeight;
      var camera = new THREE.OrthographicCamera( -1, (2 * game_size - 1) * aspect, 2 * game_size - 1, -1, 1, 1000);
      camera.position.x = 2 - game_size;
      camera.position.y = -2 * (game_size + 1);
      camera.position.z = game_size * 2;
      camera.rotation.x = Math.PI / 4;

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );


      function place_piece(piece, i, j, k, part_of_board) {
        if (piece.owner == "One") {
          var material = p1_material;
        } else {
          var material = p2_material;
        }

        if (piece.stone == "Capstone") {
          var stone = new THREE.Mesh(capstone, material);
        } else {
          var stone = new THREE.Mesh(flatstone, material);
          if (piece.stone == "Standing") {
            stone.rotation.x = Math.PI/2;
            stone.rotation.y = -Math.PI/4;
            stone.position.z = 0.5;
          } else if (piece.stone = "Flat") {
            stone.position.z = 0.15;
          }
        }

        stone.position.x = 2 * j;
        stone.position.y = 2 * i;
        stone.position.z += 0.3 * k;
        if (part_of_board) {
          board_parts.push(stone);
        }
        scene.add(stone);
      }


      // Create board out of thin squares
      for (var i = 0; i < game_size; i++) {
        for (var j = 0; j < game_size; j++) {
          var box = new THREE.BoxGeometry(2, 2, 0.01, 32);
          if ((i + j) % 2 == 0) {
            var black_square = THREE.ImageUtils.loadTexture( '../images/black_square.png' );
            var material = new THREE.MeshBasicMaterial( { map: black_square } );;
          } else {
            var white_square = THREE.ImageUtils.loadTexture( '../images/white_square.png' );
            var material = new THREE.MeshBasicMaterial( { map: white_square } );;
          }

          var block = new THREE.Mesh(box, material);
          block.position.x = i * 2;
          block.position.y = j * 2;
          board_parts.push(block);
          scene.add(block);
        }
      }

      // Create example pieces to click on
      place_piece({"owner": "One", "stone": "Capstone"}, 4, -1, 0, true);
      place_piece({"owner": "One", "stone": "Standing"}, 2, -1, 0, true);
      place_piece({"owner": "One", "stone": "Flat"}, 0, -1, 0, true);
      place_piece({"owner": "Two", "stone": "Capstone"}, 4, 5, 0, true);
      place_piece({"owner": "Two", "stone": "Standing"}, 2, 5, 0, true);
      place_piece({"owner": "Two", "stone": "Flat"}, 0, 5, 0, true);

      // Place stones based on current URL
      function refresh() {
        $.get("/game/" + gameId + "/json", function(data, status) {
          var obj, i;
          for ( i = scene.children.length - 1; i >= 0 ; i -- ) {
              obj = scene.children[ i ];
              if (obj !== camera && board_parts.indexOf(obj) == -1) {
                  scene.remove(obj);
              }
          }


          grid = data.board.grid;
          for (var i = 0; i < grid.length; i++) {
            for (var j = 0; j < grid.length; j++) {
              var cell = grid[i][j].pieces;
              for (var k = 0; k < cell.length; k++) {
                place_piece(cell[k], i, j, k, false);
              }
            }
          }
        });
        setTimeout(refresh, 1000);
      }
      refresh();

      var render = function () {
        requestAnimationFrame( render );
        renderer.render(scene, camera);
      };
      render();

      function onDocumentMouseDown(event) {
        event.preventDefault();
        if (player != null) {
          var mouse = new THREE.Vector2();
          mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

          var raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);
          var intersects = raycaster.intersectObjects(scene.children);

          if ( intersects.length > 0 ) {
            var x = intersects[0].object.position.x / 2;
            var y = intersects[0].object.position.y / 2;

            console.log(x + ", " + y);
            actOnClick(x, y);
          }
        }
      }

      var move = { type: null, place: null, data: null, extra: null};
      function actOnClick(grid_x, grid_y) {
        var xs = "abcdefgh";
        var ys = "12345678";

        // No move chosen
        if (move.type == null) {
          // Start place
          var stones = { 0: "F", 2: "S", 4: "C" };
          var players = { 0: "1"};
          players[game_size + 1] = "2";
          if ((grid_x + 1) in players && grid_y in stones) {
            move.type = "place";
            move.data = stones[grid_y] + players[grid_x + 1];
            move.place = null;
          // Start slide
          } else if (grid_x >= 0 && grid_x < game_size &&
                     grid_y >= 0 && grid_y < game_size) {
            var cell = grid[grid_y][grid_x].pieces;
            if (cell.length > 0) {
              move.type = "slide";
              move.data = null;
              move.extra = { len: cell.length, current: 0, x: grid_x, y: grid_y };
              move.place = xs[grid_x] + ys[grid_y];
            }
          }
        // Finish place
        } else if (move.type == "place") {
          if (grid_x >= 0 && grid_x < game_size &&
              grid_y >= 0 && grid_y < game_size) {
            move.place = xs[grid_x] + ys[grid_y];
            postMove();
          } else {
            move.type = null;
          }
        // Continue slide
        } else if (move.type == "slide") {
          // Established direction
          if (move.data != null && "RLUD".indexOf(move.data[0]) > -1) {
            if (grid_x == move.extra.x) {
              if (grid_y == move.extra.y) {
                move.data += "0";
                updateSlide(grid_x, grid_y);
              } else if (grid_y > move.extra.y && move.data[0] == "U") {
                move.data += grid_y - move.extra.y;
                updateSlide(grid_x, grid_y);
              } else if (grid_y < move.extra.y && move.data[0] == "D") {
                move.data += move.extra.y - grid_y;
                updateSlide(grid_x, grid_y);
              } else {
                move.type = null;
              }
            } else if (grid_y = move.extra.y) {
              if (grid_x > move.extra.x && move.data[0] == "R") {
                move.data += grid_x - move.extra.x;
                updateSlide(grid_x, grid_y);
              } else if (grid_x < move.extra.x && move.data[0] == "L") {
                move.data += move.extra.x - grid_x;
                updateSlide(grid_x, grid_y);
              } else {
                move.type = null;
              }
            } else {
              move.type = null;
            }
          } else if (grid_x == move.extra.x) {
            if (grid_y - move.extra.y == 1) {
              if (move.data != null) {
                move.data = "U" + move.data + "1";
              } else {
                move.data = "U1";
              }
              updateSlide(grid_x, grid_y);
            } else if (grid_y - move.extra.y == -1) {
              if (move.data != null) {
                move.data = "D" + move.data + "1";
              } else {
                move.data = "D1";
              }
              updateSlide(grid_x, grid_y);
            } else if (grid_y == move.extra.y) {
              if (move.data != null) {
                move.data += "0";
              } else {
                move.data = "0";
              }
              updateSlide(grid_x, grid_y);
            } else {
              move.type = null;
            }
          } else if (grid_y == move.extra.y) {
            if (grid_x - move.extra.x == 1) {
              if (move.data != null) {
                move.data = "R" + move.data + "1";
              } else {
                move.data = "R1";
              }
              updateSlide(grid_x, grid_y);
            } else if (grid_x - move.extra.x == -1) {
              if (move.data != null) {
                move.data = "L" + move.data + "1"
              } else {
                move.data = "L1";
              }
              updateSlide(grid_x, grid_y);
            } else {
              move.type = null;
            }
          } else {
            move.type = null;
          }
        } else {
          console.log("WTF, filled out but not submitted turn");
        }
        console.log(move);
      }

      function updateSlide(x, y) {
        move.extra.current += 1;
        if (move.extra.current == move.extra.len) {
          postMove();
        }
      }

      function postMove() {
        var postData = { "turn": move.place + move.data,
                         "player": player };
        console.log(postData);

        $.post("/game/" + gameId, postData, function(data, status, x) {
          console.log(data);
          console.log(status);
        });
        move.type = null;
      }
      document.addEventListener('mousedown', onDocumentMouseDown, false);
    </script>
  </body>
</html>
